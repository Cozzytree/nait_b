// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: comments.sql

package database

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createNewComment = `-- name: CreateNewComment :exec
INSERT INTO comments (by, parent_comment, content, task_id)
VALUES ($1, $2, $3, $4)
`

type CreateNewCommentParams struct {
	By            uuid.UUID
	ParentComment uuid.NullUUID
	Content       string
	TaskID        uuid.UUID
}

func (q *Queries) CreateNewComment(ctx context.Context, arg CreateNewCommentParams) error {
	_, err := q.db.ExecContext(ctx, createNewComment,
		arg.By,
		arg.ParentComment,
		arg.Content,
		arg.TaskID,
	)
	return err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM comments WHERE id = $1 AND by = $2
`

type DeleteCommentParams struct {
	ID uuid.UUID
	By uuid.UUID
}

func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) error {
	_, err := q.db.ExecContext(ctx, deleteComment, arg.ID, arg.By)
	return err
}

const getChildComments = `-- name: GetChildComments :many
SELECT c.id, c.by, c.parent_comment, c.content, c.created_at, c.updated_at, c.task_id , jsonb_build_object(
  'user_id', u.id,
  'username', u.name,
  'avatar', u.avatar,
  'email', u.email
) AS user
FROM comments AS c
LEFT JOIN users as u ON c.by = u.id
WHERE c.parent_comment = $1
OFFSET $2 LIMIT $3
`

type GetChildCommentsParams struct {
	ParentComment uuid.NullUUID
	Offset        int32
	Limit         int32
}

type GetChildCommentsRow struct {
	ID            uuid.UUID
	By            uuid.UUID
	ParentComment uuid.NullUUID
	Content       string
	CreatedAt     time.Time
	UpdatedAt     time.Time
	TaskID        uuid.UUID
	User          json.RawMessage
}

func (q *Queries) GetChildComments(ctx context.Context, arg GetChildCommentsParams) ([]GetChildCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getChildComments, arg.ParentComment, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChildCommentsRow
	for rows.Next() {
		var i GetChildCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.By,
			&i.ParentComment,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TaskID,
			&i.User,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskComments = `-- name: GetTaskComments :many
SELECT c.id, c.by, c.parent_comment, c.content, c.created_at, c.updated_at, c.task_id , jsonb_build_object(
  'user_id', u.id,
  'username', u.name,
  'avatar', u.avatar,
  'email', u.email
) AS user
FROM comments AS c
LEFT JOIN users as u ON c.by = u.id
WHERE task_id = $1 AND parent_comment IS NULL
OFFSET $2 LIMIT $3
`

type GetTaskCommentsParams struct {
	TaskID uuid.UUID
	Offset int32
	Limit  int32
}

type GetTaskCommentsRow struct {
	ID            uuid.UUID
	By            uuid.UUID
	ParentComment uuid.NullUUID
	Content       string
	CreatedAt     time.Time
	UpdatedAt     time.Time
	TaskID        uuid.UUID
	User          json.RawMessage
}

func (q *Queries) GetTaskComments(ctx context.Context, arg GetTaskCommentsParams) ([]GetTaskCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskComments, arg.TaskID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTaskCommentsRow
	for rows.Next() {
		var i GetTaskCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.By,
			&i.ParentComment,
			&i.Content,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TaskID,
			&i.User,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateComment = `-- name: UpdateComment :exec
UPDATE comments
SET content = $1,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type UpdateCommentParams struct {
	Content string
	ID      uuid.UUID
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) error {
	_, err := q.db.ExecContext(ctx, updateComment, arg.Content, arg.ID)
	return err
}
